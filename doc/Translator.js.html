<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Translator.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Translator.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>//Copyright 2014, Thomas Pronk
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License. 

/** 
 * Init JASMIN namespace
 * @private
 */
if( jasmin === undefined ) { var jasmin = function() {}; }

/**
 * Translator translates texts via a term-rewrite system. Provides the option
 * to attach callbacks to terms and to set an honorific.
 * @constructor
 */
jasmin.Translator = function() {
    this.translations = {};
    this.honorific    = undefined;
    this.callbacks    = {};
};

/**
 * Extend function based on Prototype: merge two (associative) arrays, named
 * destination and source. For any keys existing both in destination and source
 * the values of source is used.
 * @param {Object} destination 
 * @param {Object} source
 * @private
 */
jasmin.Translator.prototype.extend = function(destination, source) {
    for (var property in source) {
        if (source.hasOwnProperty(property)) {
            destination[property] = source[property];
        }
    }
    return destination;
};

/**
 * Set honorific ("t" for tu, du, jij; "v" for vous, usted, ihr, u). If a honorific
 * is set, then the Translator will look for terms prefixed with the honorific,
 * but fall back on any no-honorific form. For example, with honorific v, if 
 * Translator is requested to translate the term "hello", it will first look for
 * a translation of "v_hello"; if none exists it will just use "hello"
 * @param {String} honorific Honorific to use (can be any String)
 * @public
 */
jasmin.Translator.prototype.setHonorific = function( honorific ) {
    this.honorific = honorific;
};

/**
 * Add a set of translations
 * @param {Object}  translations Associative array of translations to add. Each key is a term, the values having keys: value for translation and status for status of translation
 * @public
 */
jasmin.Translator.prototype.addTranslations = function( translations ) {
    this.translations = this.extend( this.translations, translations );
};

/**
 * Add a callback for a term. If a callback exists for a term, and it returns a value (not undefined), then the value returned by the callback function is used as translation
 * @param {Object}  translations Associative array of translations to add. Each key is a term, the values having keys: value for translation and status for status of translation
 * @public
 */
jasmin.Translator.prototype.setCallback = function( term, callback ) {
    this.callbacks[ term ] = callback;
};


/**
 * Translate a single term (not surrounded by #[])
 * @param   {String}  term       Term to translate
 * @param   {Boolean} pretty     For any terms we cannot find translations of: if true, return term surrounded with "!", if false return undefined (default = true)
 * @public
 */
jasmin.Translator.prototype.translateTerm = function( term, pretty ) {
    // Pretty true by default
    pretty = pretty === undefined? true: pretty;
    
    // First look in callbacks
    if( this.callbacks[ term ] !== undefined ) {
        // Callback found, use it to get translation
        return this.translate( this.callbacks[ term ](), pretty );
    }
    
    // No callback, next check translations
    
    // Check translation for honorific (if specified)
    var translation;
    if( this.honorific !== undefined ) {
        translation = this.translations[ this.honorific + "_" + term ];
    }
    
    // If no translation found yet, try without honorific
    if( translation === undefined ) {
        translation = this.translations[ term ];
    } 
    
    // Translation found?
    if( translation === undefined ) {
        // If not pretty, return undefined
        if( !pretty ) {
            return undefined;
        }
            
        // No, return original term in exclamation marks
        return "!" + term + "!";
    } else {
        // Tes, return substituted translation
        return this.translate( translation, pretty );
    }
};

/**
 * Translate a text that contains 0 or more terms: Find terms in haystack
 * (as identified by #[this_is_a_term], replace each by its translation, 
 * return haystack
 * @param   {String}  haystack   Text containing 0 or more terms
 * @param   {Boolean} pretty     For any terms we cannot find translations of: if true, return term surrounded with "!", if false return undefined (default = true)
 * @public
 */
jasmin.Translator.prototype.translate = function( haystack, pretty ) {
    // Pretty true by default
    pretty = pretty === undefined? true: pretty;
    
    
    // *** Replace all hash tags
    // Regexp to Filter tag out of term
    var regExpTerm = new RegExp( /[#]\[+[A-Za-z0-9-_ ]+?\]/ ); 
    // Filter term out of tag
    var regExpTag;          

    // For each tag in the haystack, translate it
    var tag = true;
    var tag, term, translation;
    
    // More tags to go? 
    while( tag !== null ) {
        // Get enxt tag
        tag = regExpTerm.exec( haystack );
        if( tag !== null ) {
            // Tag found, get term
            regExpTag  = new RegExp( /[A-Za-z0-9-_ ]+/g );
            term = regExpTag.exec( tag );
            
            // Translate term
            translation = this.translateTerm( term );
            
            // Replace tag by translated term
            haystack = haystack.replace( regExpTerm, translation );
        }
    }
    
    return haystack;
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="jasmin.EventManager.html">EventManager</a></li><li><a href="jasmin.Loader.html">Loader</a></li><li><a href="jasmin.RequestManager.html">RequestManager</a></li><li><a href="jasmin.ResponseManager.html">ResponseManager</a></li><li><a href="jasmin.ScalableCanvas.html">ScalableCanvas</a></li><li><a href="jasmin.Slideshow.html">Slideshow</a></li><li><a href="jasmin.Statistics.html">Statistics</a></li><li><a href="jasmin.SyncTimer.html">SyncTimer</a></li><li><a href="jasmin.TableLogger.html">TableLogger</a></li><li><a href="jasmin.Translator.html">Translator</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-dev</a> on Sun Mar 29 2015 01:02:12 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
